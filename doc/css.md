# shadow.css - rough design draft

Trying to build a solution for CSS-in-CLJ(S).

Using [tailwindcss](https://www.tailwindcss.com) style aliases to reduce user typing and improving consistency throughout styles. However, tailwind is rather constrained by the fact that it needs to fit in a `class` attribute string. We don't want that limitation, as sometimes it is more expressive to write actual CSS.

Writing actual CSS however requires context switching and jumping between files, we instead want styles to be defined where they are used. Directly in the namespaces, alongside other code.

Other CSS-in-X solution often require naming too many things which can get annoying, especially for utility layout elements. Names here are entirely optional and are covered by other CLJ constructs  (eg. `def`, `let`, etc) instead.

## Requirements

- must be usable in CLJ, CLJS and any other dialect (for now focusing on CLJ+CLJS)
- must be able to combine styles from all .clj, .cljc, .cljs, .cljd sources
- each platform must be aware of other platforms styles (CLJ<->CLJS), if they may end up on the same context (eg. webpage)
- must be usable in libraries
- must have an option to generate zero client side JS code (and should do so by default)
- should emit well-structured CSS
- should be statically analyzable (better tool support)
- should be combinable with other methods (post-compilation)
- should be possible to DCE

# Syntax

Abstract:
```
(css <root-part+>)

<root-part> =
    <alias>
  | <passthrough>
  | <css-map>
  | <nested-selector>
  
<part> =
    <alias>
  | <css-map>
  | <nested-selector>
  
<alias> = keyword?
<passthrough> = string?
<css-map> = map-of keyword? <css-val>
<css-val> = string? | number? | <alias>
<nested-selector = [<selector> <part+>]
<selector> = <css-string?> | <alias>
<css-string> = string including & | css media query 
```

In Clojure terms, everything is done via the provided `css` macro.

```clojure
;; keywords represent pre-defined aliases
;; maps are literal CSS definitions
(css :px-4 {:color "red"})

;; all the macro generates is a classname. the macro does not generate any css itself
"some_ns__Lx_Cx"
;; optionally, optimized combination of util classes (with minified names) may be generated instead
"px-4 aA"

;; strings are passed through as a convenience when using other CSS techs (eg. tailwind)
(css "px-4 my-2" {:background "#123"})
;; basically just a shorter version of
(str "px-4 my-2 " (css {:background "#123"}))

;; both yield
"px-4 my-2 some_ns__Lx_Cx"

;; map keys as keywords represent literal CSS rule keys, they are not modified in any way
;; map values are string, numbers, or aliases
;; strings are passed through as is
;; numbers are translated using the same numbering scheme the aliases use
;; there are exceptions where numbers are just used as is, eg {:flex 1}
;; if px or other specific units are required they should be expressed as a string
(css :px-4)
;; just short for
(css {:padding-left 4 :padding-right 4}) 

;; sub-selectors can be used to target nested elements or pseudo-classes
;; & is replaced with the actual generated classname and must be present
(css ["&:hover" {:color "green"}])

;; except for strings starting with @ representing media queries
(css ["@media (min-width: 1024px)" :px-8])

;; aliases are also allowed in the selector place for commonly used selectors
(css :px-4 [:ui/lg :px-8])

;; if using an alias it must resolve to a string, otherwise yields an invalid style
(css :px-4 [:px-8]) ;; invalid

;; sub-selectors may be nested
(css
  :px-4
  ["&:hover" {:color "red"}]
  [:ui/lg
   :px-8
   ["&:hover" {:color "green"}]])
```

All rules are combined sequentially per selector, later values may override previous ones.

Symbols are not used. They might confuse tools or users as to what they may resolve to, when in fact no resolving is ever done. No other forms are valid. `css` definitions are entirely static, no local code may influence them. Aliases however provide a way to customize what CSS is actually generated.

The intent here is to have something in the code that can be extracted just by parsing the source, without actually eval-ing anything. This is necessary because often styles need to be generated and served before the actual page HTML. Generating styles during evaluation is too late, but should be an option for more dynamic uses.

## Library Use

A primary goal of this is making it usable in libraries, for any platform.

Traditionally libraries will just bundle their own required CSS, which often leads to unnecessary duplication or just makes things harder to optimize. With alias keywords it also becomes much easier to customize library css rules. CSS Variables can also be used of course, but aliases offer even more flexibility.

Instead, libraries will contain a resource file that should contain all their CSS definitions as their raw CLJ form. These resource files will be generated by the shadow.css tooling and loaded when the actual final .css file is generated in projects. Only styles from referenced namespaces will be included and everything can be optimized together if needed. The resource files reduce the need for additional processing of sources. Discovery of files in Jars can end up very expensive, and is wasted work for libraries that don't actually contain any CSS.

## Cross Platform Use

CSS is generated as a build step, not at runtime.

Often there will be some CLJ server side code generating HTML+CSS, and then some additional CLJS client side code doing the same. The styles need to be generated before either is processed, so they can be served up as a regular (and cacheable) `.css` files. Dynamic generation at runtime should be possible, but not the default as it is much less efficient.

For CLJS `:advanced` compilation may help eliminate unused rules and purge them from the generated .css file.

CSS rules from namespaces that aren't referenced must not be included. References may come from source code or build configs.

## Integration with other Systems

It is entirely fine to use the shadow.css output and feeding it into another CSS tool pipeline. Some library may just want to use some CSS but without `(css ...)`. ns metadata or build configuration can be used to instruct the shadow.css tools to include CSS from other sources.

```clojure
(ns some.library
  {:shadow.css/include
   ["some/library/static.css"]} ;; referencing other resources on the classpath
   ...)
```

These references however are not processed in any way, and are just included in the final output unmodified. There should be no assumption that these will be processed by some other specific tool again.

## Possible Optimizations

As of now each `css` will end up generating one classname, using the namespace and line/column information for the naming purposes. However, as mentioned earlier this doesn't need to be so. In addition to the `.css` file a lookup table may be generated. That way the class that ends up getting used in the code can be overridden. For CLJ that can be used at runtime. For CLJS this would need to be done at build time as it otherwise doesn't benefit from DCE.

Also, there may be multiple places in a codebase that have `(css :px-4)` and there is absolutely no need to have a specific class for each. So, one optimization is just emitting utility classnames ala tailwind. There'll also be common combinations that may also generate their own utility.

Instead of the long verbose names it could also generate short names, similar to what `:advanced` produces. For development however these long names are actually useful since they tell you exactly where they were defined just by looking at the name.

Testing should also be done if shortening is even necessary. GZIP is very good at optimizating repetition after all.

# Build

# Usage
